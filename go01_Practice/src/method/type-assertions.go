package main

import "fmt"

//  类型断言 提供了访问接口值底层具体值的方式。
//	t := i.(T)
//	该语句断言接口值 i 保存了具体类型 T，并将其底层类型为 T 的值赋予变量 t。
//	若 i 并未保存 T 类型的值，该语句就会触发一个恐慌。
//	为了 判断 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。
//	t, ok := i.(T)
//	若 i 保存了一个 T，那么 t 将会是其底层值，而 ok 为 true。
//	否则，ok 将为 false 而 t 将为 T 类型的零值，程序并不会产生恐慌。
//	请注意这种语法和读取一个映射时的相同之处。

//  类型断言是 Go 语言中的一个特性，这个特性允许你将接口类型的变量转换到一个具体类型的变量，从而能让你调用具体类型变量的方法和字段，或者判断接口变量的具体类型。
//  定义一个变量为接口类型后，你无法确定这个变量的具体类型是什么。类型断言可以用于获取接口的底层值的真正类型。
//  类型断言的常用语法是： t := i.(T)，其中 i 是接口类型的变量，`T` 是我们想要断言的类型，`t` 会获取 i 的底层值，然后转化为 T 类型。
//  如果 i 并没有完全实现 T，那么这个语句会引发一个 panic。为了避免这种情况，Go 语言    提供了另外一种语法：
//  t, ok := i.(T)
//  这种类型断言语法会返回两个值：底层值和一个布尔值。如果 i 实现了 T，那么 t 会是 i 的底层值，`ok` 会是 true。如果 i 没有实现 T，那么 t 会是 T 类型的零值，`ok` 会是 false。


func main() {
	//这里我定义了一个接口类型的变量，但是无法确定这个变量的具体类型是什么
	var i interface{} = "hello"

	s := i.(string)
	fmt.Println(s)

	//如果 i实现了 string类型，那么 s会是 i的底层值，'ok'就是 true，如果 i 没有实现 string，那么 t 会是 string 类型的零值，`ok` 会是 false。
	s, ok := i.(string)
	fmt.Println(s, ok)

	//如果 i实现了 float64类型，那么 f会是 i的底层值，'ok'就是 true，如果 i 没有实现 float64类型，那么 t 会是 float64类型的零值,为 0，`ok` 会是 false。
	f, ok := i.(float64)
	fmt.Println(f, ok)

	//因为这里i没有实现 float64类型，所以这里调用会报错
	f = i.(float64) // 报错(panic)
	fmt.Println(f)
}
